---
title: "NDVI: Generalized Linear Mixed Models"
author: "Joe Celebrezze"
date: "2024-03-27"
output: html_document
---

The previous 'mixed_effects_models.Rmd' was convoluted, as it had the GLMM selections and the MEM selections all wrapped up into one script. As of 11/24, this script is used for all edits to GLMM selections and associated visualizations, diagnostic plots, etc.

# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
here = here::here

source(here("scripts", "source_code.R"))
source(here("scripts", "mem.selection.function.R"))

library(lme4) # for mixed effects models
library(lmerTest)
library(sjPlot) # for tab_model
library(performance)
library(cowplot)
library(gtools)
library(GGally) # for ggcorr()
library(glmmTMB) # generalized linear mixed models
library(kableExtra)
library(DHARMa) # model diagnostics
library(broom.mixed) # for tidy for glmmTMB
plot_grid = cowplot::plot_grid
group_by = dplyr::group_by

wide.df <- read.csv(here('data', 'processed_data', 'NDVI', 'wide.df.csv')) %>% 
  select(-X)
colnames(wide.df)[14:37] <- c(0:23)
long.df <- read.csv(here('data', 'processed_data', 'NDVI', 'long.df.csv')) %>% 
  select(-X)
field.data.both <- read.csv(here('data', 'processed_data', 'NDVI', 'field.data.both.csv')) %>% 
  select(-X)
field.cluster.df <- read.csv(here('data', 'processed_data', 'NDVI', 'field.cluster.df.csv'))
colnames(field.cluster.df)[26:49] <- c(0:23)
```

# Data Wrangling
```{r}
# No NAs, scale and center all variables
mem.df <- field.cluster.df %>% 
  mutate(postfire_tmean = (postfire_tmin + postfire_tmax)/2) %>%  #delete after rerunning data wrangling
  drop_na(slope) %>% 
  mutate(grass.pct = scale(grass.pct), herb.pct = scale(herb.pct), shrub.pct = scale(shrub.pct), seedling.pct = scale(seedling.pct), log.regen.density = scale(log.regen.density), log.seedling.density = scale(log.seedling.density), green.pct = scale(green.pct), npv.pct = scale(npv.pct), densiometer = scale(densiometer), postdisturbance_ndvi = scale(postdisturbance_ndvi), delta_ndvi = scale(delta_ndvi), relative_regrowth = scale(relative_regrowth), pct_recovery = scale(pct_recovery), postfire_fitted_rsq = scale(postfire_fitted_rsq), postfire_fitted_slope = scale(postfire_fitted_slope), hli = scale(hli), precip = scale(precip), tmean = scale(tmean), vpdmax = scale(vpdmax), seedling.density = scale(seedling.density), aspect = scale(aspect), slope = scale(slope), dndvi = scale(dndvi), canopy_cover = scale(canopy_cover), cwd_present = scale(cwd_present), elevation = scale(elevation), postfire_ppt = scale(postfire_ppt), postfire_tmax = scale(postfire_tmax), postfire_vpdmax = scale(postfire_vpdmax), postfire_tmean = scale(postfire_tmean))

mem.predictors <- mem.df %>% 
  select(delta_ndvi, relative_regrowth , postfire_fitted_slope , elevation , slope , hli , aspect , canopy_cover, postfire_ppt, postfire_tmean, postfire_vpdmax, dndvi) # omitted postfire_vpdmax, pct_recovery, aspect, postfire_tmax, canopy_cover to add elevation, postfire_ppt, cwd_present, dndvi , postfire_tmean, hli

int.predictors <- c('delta_ndvi', 'relative_regrowth' , 'postfire_fitted_slope' , 'elevation' , 'slope' , 'hli' , 'aspect' , 'canopy_cover', 'postfire_ppt', 'postfire_tmean', 'postfire_vpdmax', 'dndvi')

mem.df.glmm <- field.cluster.df %>% 
  mutate(postfire_tmean = (postfire_tmin + postfire_tmax)/2) %>%  #delete after rerunning data wrangling
  drop_na(slope) %>% 
  mutate(postdisturbance_ndvi = scale(postdisturbance_ndvi), delta_ndvi = scale(delta_ndvi), relative_regrowth = scale(relative_regrowth), pct_recovery = scale(pct_recovery), postfire_fitted_rsq = scale(postfire_fitted_rsq), postfire_fitted_slope = scale(postfire_fitted_slope), hli = scale(hli), precip = scale(precip), tmean = scale(tmean), vpdmax = scale(vpdmax), seedling.density = scale(seedling.density), aspect = scale(aspect), slope = scale(slope), dndvi = scale(dndvi), canopy_cover = scale(canopy_cover), cwd_present = scale(cwd_present), elevation = scale(elevation), postfire_ppt = scale(postfire_ppt), postfire_tmax = scale(postfire_tmax), postfire_vpdmax = scale(postfire_vpdmax), postfire_tmean = scale(postfire_tmean))
```

# Correlation Matrix
```{r}
mem.df %>% 
  select(delta_ndvi, relative_regrowth , postfire_fitted_slope , elevation , slope , hli , precip , tmean, postfire_ppt, postfire_tmean, cwd_present, dndvi, aspect, postfire_vpdmax, pct_recovery, postfire_tmax, canopy_cover, shrub.pct, seedling.pct, log.seedling.density, log.regen.density, grass.pct, green.pct, npv.pct) %>% 
  ggcorr(label = T)
```

# 1. Full Model Selections
## Spectral
### Data Wrangling
```{r}
glmm.predictors.spectral <- mem.df.glmm %>% 
  select(relative_regrowth, postfire_fitted_slope, pct_recovery, delta_ndvi, dndvi, canopy_cover) # omitted postfire_vpdmax, pct_recovery, aspect, postfire_tmax, canopy_cover to add elevation, postfire_ppt, cwd_present, dndvi , postfire_tmean, hli

glmm.int.predictors.spectral <- c('delta_ndvi', 'relative_regrowth', 'postfire_fitted_slope', 'pct_recovery', 'canopy_cover', 'dndvi')
```

### % Seedling
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
seedling.gaussian.glmm <- glmmTMB(seedling.pct ~ elevation + postfire_ppt + (1|fire), mem.df.glmm, gaussian)
simulated.seedling.gaussian.glmm <- simulateResiduals(fittedModel = seedling.gaussian.glmm, n = 1000)
testZeroInflation(simulated.seedling.gaussian.glmm) # zero-inflated
## Using AIC
seedling.gaussian.glmm.zi <- glmmTMB(seedling.pct ~ elevation + postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
AIC(seedling.gaussian.glmm)
AIC(seedling.gaussian.glmm.zi) # significant improvement

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
simulated.seedling.gaussian.glmm <- simulateResiduals(fittedModel = seedling.gaussian.glmm.zi, n = 1000)
plot(simulated.seedling.gaussian.glmm) # looks meh

seedling.binomial.glmm <- glmmTMB(seedling.pct/100 ~ elevation + postfire_ppt + (1|fire), mem.df.glmm, binomial, ziformula = ~1)
simulated.seedling.binomial.glmm <- simulateResiduals(fittedModel = seedling.binomial.glmm, n = 1000)
plot(simulated.seedling.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with just ziformula = ~1)
seed.glmm.selection.gaussian <- glmm.selection('seedling.pct', glmm.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '1')
seed.model.df.gaussian <- seed.glmm.selection.gaussian[[1]]
seed.mod.list.gaussian <- seed.glmm.selection.gaussian[[2]]

# 4. Interactions
seed.glmm.int.selection <- glmm.int.selection('seedling.pct', glmm.int.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '1')
seed.glmm.int.df <- seed.glmm.int.selection[[1]] # sig. worse

# 5. Zero-inflated Model Selection(s): if not too much of an ask, try to run these for all 'top-performing models'
seed.glmm.zi.selection <- glmm.zi.selection('seedling.pct ~ canopy_cover*postfire_fitted_slope + (1 | fire)', 'seedling.pct', glmm.predictors.spectral, mem.df.glmm, gaussian)
seed.model.df.gaussian.zi <- seed.glmm.zi.selection[[1]]
seed.mod.list.gaussian.zi <- seed.glmm.zi.selection[[2]]

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(seed.mod.list.gaussian.zi[[7]])
summary(seed.mod.list.gaussian.zi[[8]])
summary(seed.mod.list.gaussian.zi[[26]])
# based on significance of zero inflation predictors, I think we should stick to simple model which only includes canopy cover in ZI formula

# 7. Define top model and run model diagnostic plots
seedling.top.model <- glmmTMB(seedling.pct ~ canopy_cover*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula = ~canopy_cover)
summary(seedling.top.model)
simulated.seedling <- simulateResiduals(fittedModel = seedling.top.model, n = 1000)
plot(simulated.seedling) # looks pretty good
testZeroInflation(simulated.seedling) # looks good
testUniformity(simulated.seedling) # looks good
testDispersion(simulated.seedling) # looks good
```

### % Shrub
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
shrub.gaussian.glmm <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + dndvi + (1|fire), mem.df.glmm, gaussian)
simulated.shrub.gaussian.glmm <- simulateResiduals(fittedModel = shrub.gaussian.glmm, n = 1000)
testZeroInflation(simulated.shrub.gaussian.glmm) # zero-inflated
## Using AIC
shrub.gaussian.glmm.zi <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + dndvi + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
AIC(shrub.gaussian.glmm)
AIC(shrub.gaussian.glmm.zi) # not a significant improvement; stick to no zero inflation

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
plot(simulated.shrub.gaussian.glmm) # looks good!

shrub.binomial.glmm <- glmmTMB(shrub.pct/100 ~ delta_ndvi + postfire_fitted_slope + dndvi + (1|fire), mem.df.glmm, binomial)
simulated.shrub.binomial.glmm <- simulateResiduals(fittedModel = shrub.binomial.glmm, n = 1000)
plot(simulated.shrub.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (no zero inflation)
shrub.glmm.selection.gaussian <- glmm.selection('shrub.pct', glmm.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '0')
shrub.model.df.gaussian <- shrub.glmm.selection.gaussian[[1]]
shrub.mod.list.gaussian <- shrub.glmm.selection.gaussian[[2]]

# 4. Interactions
shrub.glmm.int.selection <- glmm.int.selection('shrub.pct', glmm.int.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '0')
shrub.glmm.int.df <- shrub.glmm.int.selection[[1]]
shrub.glmm.int.list <- shrub.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s): not applicable

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(shrub.mod.list.gaussian[[8]]) # lowest AIC; all sig
summary(shrub.mod.list.gaussian[[31]]) # rel regrowth not sig
summary(shrub.mod.list.gaussian[[27]]) # dndvi not sig
summary(shrub.glmm.int.list[[2]]) # interaction not sig
# Selecting model no. 8

# 7. Define top model and run model diagnostic plots
shrub.top.model <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + (1 | fire), mem.df.glmm, gaussian)
simulated.shrub <- simulateResiduals(fittedModel = shrub.top.model, n = 1000)
plot(simulated.shrub) # looks great
testZeroInflation(simulated.shrub) # zero inflated, but only one zero so not a big deal
testUniformity(simulated.shrub) # looks good
testDispersion(simulated.shrub) # looks good
```

### % Grass
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
grass.gaussian.glmm <- glmmTMB(grass.pct ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), mem.df.glmm, gaussian)
simulated.grass.gaussian.glmm <- simulateResiduals(fittedModel = grass.gaussian.glmm, n = 1000)
testZeroInflation(simulated.grass.gaussian.glmm) # zero-inflated
## Using AIC
grass.gaussian.glmm.zi <- glmmTMB(grass.pct ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
AIC(grass.gaussian.glmm)
AIC(grass.gaussian.glmm.zi) # not significant improvement; but we can test anyways

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
plot(simulated.grass.gaussian.glmm) # qqplot looks good; residual plot looks meh

grass.binomial.glmm <- glmmTMB(grass.pct/100 ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), mem.df.glmm, binomial)
simulated.grass.binomial.glmm <- simulateResiduals(fittedModel = grass.binomial.glmm, n = 1000)
plot(simulated.grass.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with no zero inflation)
grass.glmm.selection.gaussian <- glmm.selection('grass.pct', glmm.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '0')
grass.model.df.gaussian <- grass.glmm.selection.gaussian[[1]]
grass.mod.list.gaussian <- grass.glmm.selection.gaussian[[2]]

# 4. Interactions
grass.glmm.int.selection <- glmm.int.selection('grass.pct', glmm.int.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '0')
grass.glmm.int.df <- grass.glmm.int.selection[[1]] # sig. better
grass.glmm.int.mod.list <- grass.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s): not working for % grass because only a few zero values; however, we will try a couple of different zero inflation formulas to test the impact on the AIC
grass.glmm.zi.selection.mod1 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula= ~ 1) 
AIC(grass.glmm.zi.selection.mod1) # sig. better
grass.glmm.zi.selection.mod2 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula= ~ canopy_cover) 
AIC(grass.glmm.zi.selection.mod2) # sig. better
grass.glmm.zi.selection.mod3 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula= ~ postfire_fitted_slope) 
AIC(grass.glmm.zi.selection.mod3) # sig. better; best of three


# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
mod1 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula= ~ postfire_fitted_slope)
summary(mod1)
AIC(mod1) # third lowest
mod2 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + pct_recovery + (1|fire), mem.df.glmm, gaussian, ziformula= ~ postfire_fitted_slope)
summary(mod2) # pct recovery is n.s.
AIC(mod2) # second lowest
mod3 <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula= ~ postfire_fitted_slope)
summary(mod3) # delta ndvi is marginally n.s.
AIC(mod3) # lowest, barely
rm(mod1, mod2, mod3)

# 7. Define top model and run model diagnostic plots
grass.top.model <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_fitted_slope) 
simulated.grass <- simulateResiduals(fittedModel = grass.top.model, n = 1000)
plot(simulated.grass) # looks good
testZeroInflation(simulated.grass) # looks good
testUniformity(simulated.grass) # looks good
testDispersion(simulated.grass) # looks good
```

### Regen Density
Picking out distribution: for density, we can test gaussian (if log-transformed), poisson, negative binomial 1 and negative binomial 2 (more options)
```{r}
# 1. Test for zero inflation (using gaussian model w/ log.regen.density, for now)
## Using DHARMa package
regen.gaussian.glmm <- glmmTMB(log.regen.density ~ slope*postfire_vpdmax + (1|fire), mem.df.glmm, gaussian)
simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.gaussian.glmm, n = 1000)
testZeroInflation(simulated.regen.gaussian.glmm) # zero-inflated
## Using AIC
regen.gaussian.glmm.zi <- glmmTMB(log.regen.density ~ slope*postfire_vpdmax + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
AIC(regen.gaussian.glmm)
AIC(regen.gaussian.glmm.zi) # significant improvement

# 2. Using top models identified in gaussian model selection (above), test different families  and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.gaussian.glmm.zi, n = 1000)
plot(simulated.regen.gaussian.glmm) # actually, looks great!

regen.nbinom1.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), mem.df.glmm, nbinom1, ziformula = ~1)
simulated.regen.nbinom1.glmm <- simulateResiduals(fittedModel = regen.nbinom1.glmm, n = 1000)
plot(simulated.regen.nbinom1.glmm) # looks a bit rough; definitely worse than gaussian

regen.nbinom2.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), mem.df.glmm, nbinom2, ziformula = ~1)
simulated.regen.nbinom2.glmm <- simulateResiduals(fittedModel = regen.nbinom2.glmm, n = 1000)
plot(simulated.regen.nbinom2.glmm) # looks meh; worse than gaussian

regen.poisson.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), mem.df.glmm, poisson, ziformula = ~1)
simulated.regen.poisson.glmm <- simulateResiduals(fittedModel = regen.poisson.glmm, n = 1000)
plot(simulated.regen.poisson.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN or NBINOM2
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (for now, just with ziformula = ~1)
regen.glmm.selection.gaussian <- glmm.selection('log.regen.density', glmm.predictors.spectral, mem.df.glmm, gaussian, zero.inflation = '1')
regen.model.df.gaussian <- regen.glmm.selection.gaussian[[1]]
regen.mod.list.gaussian <- regen.glmm.selection.gaussian[[2]]

regen.glmm.selection.nbinom2 <- glmm.selection('regen.density', glmm.predictors.spectral, mem.df.glmm, nbinom2, zero.inflation = '1')
regen.model.df.nbinom2 <- regen.glmm.selection.nbinom2[[1]]
regen.mod.list.nbinom2 <- regen.glmm.selection.nbinom2[[2]]
# AIC for the two families is incomparable, Rsq is higher for nbinom2; let's check out diagnostic plots to decide which to choose
regen.mod.list.gaussian[[36]]
regen.mod.list.nbinom2[[36]]

simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.mod.list.gaussian[[16]], n = 1000)
plot(simulated.regen.gaussian.glmm) # looks good, maybe a bit off
simulated.regen.nbinom2.glmm <- simulateResiduals(fittedModel = regen.mod.list.nbinom2[[16]], n = 1000)
plot(simulated.regen.nbinom2.glmm) # looks meh

# although the nbinom2 looks slightly worse than the gaussian, I am going to select this distribution, as it prevents the log-transformation

# 4. Interactions
regen.glmm.int.selection <- glmm.int.selection('regen.density', glmm.int.predictors.spectral, mem.df.glmm, nbinom2, zero.inflation = '1')
regen.glmm.int.df <- regen.glmm.int.selection[[1]] # sig. better
regen.glmm.int.mod.list <- regen.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s)
regen.glmm.zi.selection <- glmm.zi.selection('regen.density ~ relative_regrowth*canopy_cover + (1 | fire)', 'regen.density', glmm.predictors.spectral, mem.df.glmm, nbinom2)
regen.model.df.nbinom2.zi <- regen.glmm.zi.selection[[1]]
regen.mod.list.nbinom2.zi <- regen.glmm.zi.selection[[2]]
# By intercept is best model...

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
## Adding other variables did not improve model performance, sticking with interation term only

# 7. Define top model and run model diagnostic plots
regen.top.model <- glmmTMB(regen.density ~ relative_regrowth*canopy_cover + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~1) 
AIC(regen.top.model)
summary(regen.top.model)
simulated.regen <- simulateResiduals(fittedModel = regen.top.model, n = 1000)
plot(simulated.regen) # looks decent..
testZeroInflation(simulated.regen) # looks good
testUniformity(simulated.regen) # not uniform
testDispersion(simulated.regen) # looks good
```


## All
Using same error distributions as identified in above selection
### Data Wrangling
```{r}
glmm.predictors <- mem.df.glmm %>% 
  select(relative_regrowth, postfire_fitted_slope, delta_ndvi, canopy_cover, dndvi, elevation, slope, postfire_ppt, postfire_tmean) #omitted postfire_vpdmax, pct_recovery, aspect, postfire_tmax, canopy_cover to add elevation, postfire_ppt, cwd_present, dndvi , postfire_tmean, hli

# omitted: canopy_cover, pct_recovery, hli, aspect

glmm.predictors.zi <- glmm.predictors

glmm.int.predictors <- c('relative_regrowth', 'postfire_fitted_slope', 'delta_ndvi', 'pct_recovery', 'canopy_cover', 'dndvi', 'elevation', 'slope', 'postfire_ppt', 'postfire_tmean', 'postfire_vpdmax')
```

### % Seedling
Picking out distribution: Gaussian

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with just ziformula = ~1)
seed.glmm.selection.gaussian <- glmm.selection('seedling.pct', glmm.predictors, mem.df.glmm, gaussian, zero.inflation = '1')
seed.model.df.gaussian <- seed.glmm.selection.gaussian[[1]]
seed.mod.list.gaussian <- seed.glmm.selection.gaussian[[2]]

# 4. Interactions
seed.glmm.int.selection <- glmm.int.selection('seedling.pct', glmm.int.predictors, mem.df.glmm, gaussian, zero.inflation = '1')
seed.glmm.int.df <- seed.glmm.int.selection[[1]] # sig. better

# 5. Zero-inflated Model Selection(s)
seed.glmm.zi.selection <- glmm.zi.selection('seedling.pct ~ postfire_fitted_slope*postfire_ppt + (1 | fire)', 'seedling.pct', predictors = glmm.predictors.zi, df = mem.df.glmm, gaussian)
seed.model.df.gaussian.zi <- seed.glmm.zi.selection[[1]]
seed.mod.list.gaussian.zi <- seed.glmm.zi.selection[[2]]

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(seed.mod.list.gaussian.zi[[184]]) # postfire ppt and slope sig., but c.c. and tmean n.s.
summary(seed.mod.list.gaussian.zi[[71]])  # postfire ppt sig., but not slope, c.c.
summary(seed.mod.list.gaussian.zi[[289]]) # postfire ppt and slope sig., but c.c. and delta ndvi and tmean n.s.
summary(seed.mod.list.gaussian.zi[[43]]) # postfire ppt and slope sig.
summary(seed.mod.list.gaussian.zi[[92]]) # postfire ppt sig., not slope or delta ndvi
# selecting zero-inflated model with canopy cover (lowest AIC, sig. predictor)

m1 <- glmmTMB(seedling.pct ~ postfire_fitted_slope*postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt + slope)
AIC(m1)
m2 <- glmmTMB(seedling.pct ~ postfire_fitted_slope*postfire_ppt + relative_regrowth + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt + slope)
AIC(m2) # lower AIC
m3 <- glmmTMB(seedling.pct ~ postfire_fitted_slope*postfire_ppt + postfire_tmean + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt + slope)
AIC(m3) # lower AIC


# 7. Define top model and run model diagnostic plots
seedling.top.model <- glmmTMB(seedling.pct ~ postfire_fitted_slope*postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt + slope)
simulated.seedling <- simulateResiduals(fittedModel = seedling.top.model, n = 1000)
plot(simulated.seedling) # looks good
testZeroInflation(simulated.seedling) # looks good
testUniformity(simulated.seedling) # not uniform
testDispersion(simulated.seedling) # looks good
```

### % Shrub
Picking out distribution: Gaussian

Choosing predictors and ziformula
```{r}
# 3. Model Selection (no zero inflation)
shrub.glmm.selection.gaussian <- glmm.selection('shrub.pct', glmm.predictors, mem.df.glmm, gaussian, zero.inflation = '0')
shrub.model.df.gaussian <- shrub.glmm.selection.gaussian[[1]]
shrub.mod.list.gaussian <- shrub.glmm.selection.gaussian[[2]]

# 4. Interactions
shrub.glmm.int.selection <- glmm.int.selection('shrub.pct', glmm.int.predictors, mem.df.glmm, gaussian, zero.inflation = '0')
shrub.glmm.int.df <- shrub.glmm.int.selection[[1]] # sig. worse
shrub.glmm.int.mod.list <- shrub.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s): not applicable

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(shrub.mod.list.gaussian[[11]]) # all sig.
summary(shrub.mod.list.gaussian[[206]]) # postfire tmean, slope not sig
summary(shrub.mod.list.gaussian[[76]]) # ppt not sig
summary(shrub.mod.list.gaussian[[77]]) # tmean not sig.
summary(shrub.mod.list.gaussian[[79]]) # slope not sig
summary(shrub.mod.list.gaussian[[71]]) # elev not sig
summary(shrub.glmm.int.mod.list[[11]]) # interaction not sig
# Selecting model no. 11; lowest BIC, all predictors sig., and AIC not sig. higher than lowest AIC

# 7. Define top model and run model diagnostic plots
shrub.top.model <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + (1 | fire), mem.df.glmm, gaussian)
AIC(shrub.top.model)
simulated.shrub <- simulateResiduals(fittedModel = shrub.top.model, n = 1000)
plot(simulated.shrub) # looks great
testZeroInflation(simulated.shrub) # zero inflated, but only one zero so not a big deal
testUniformity(simulated.shrub) # looks good
testDispersion(simulated.shrub) # looks good
```

### % Grass
Picking out distribution: Gaussian

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with no zero inflation)
grass.glmm.selection.gaussian <- glmm.selection('grass.pct', glmm.predictors, mem.df.glmm, gaussian, zero.inflation = '0')
grass.model.df.gaussian <- grass.glmm.selection.gaussian[[1]]
grass.mod.list.gaussian <- grass.glmm.selection.gaussian[[2]]

# 4. Interactions
grass.glmm.int.selection <- glmm.int.selection('grass.pct', glmm.int.predictors, mem.df.glmm, gaussian, zero.inflation = '0')
grass.glmm.int.df <- grass.glmm.int.selection[[1]] # sig. better
grass.glmm.int.mod.list <- grass.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s): not working for % grass because only a few zero values; however, we will try a couple of different zero inflation formulas to test the impact on the AIC
grass.glmm.zi.selection.mod1 <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + (1|fire), mem.df.glmm, gaussian, ziformula= ~ postfire_tmean) 
AIC(grass.glmm.zi.selection.mod1) # sig worse
grass.glmm.zi.selection.mod2 <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + (1|fire), mem.df.glmm, gaussian, ziformula= ~ 1) 
AIC(grass.glmm.zi.selection.mod2) # pretty good
grass.glmm.zi.selection.mod3 <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + (1|fire), mem.df.glmm, gaussian, ziformula= ~ pct_recovery) 
AIC(grass.glmm.zi.selection.mod3) # about the same, but slightly better

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
# Testing if other predictors improve model
m1 <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula= ~ pct_recovery) 
AIC(m1) # sig. better
m2 <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + postfire_ppt + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula= ~ pct_recovery) 
AIC(m2) # slightly better than m1; Also tried other predictors but not shown above to keep code clean

# 7. Define top model and run model diagnostic plots
grass.top.model <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + postfire_ppt + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula= ~ pct_recovery) 
simulated.grass <- simulateResiduals(fittedModel = grass.top.model, n = 1000)
plot(simulated.grass) # looks pretty good
testZeroInflation(simulated.grass) # looks good
testUniformity(simulated.grass) # looks good
testDispersion(simulated.grass) # looks good
```

### Regen Density
Picking out distribution: Negative binomial 2

Choosing predictors and ziformula
```{r}
# 3. Model Selection (for now, just with ziformula = ~1)
regen.glmm.selection.nbinom2 <- glmm.selection('regen.density', glmm.predictors, mem.df.glmm, nbinom2, zero.inflation = '1')
regen.model.df.nbinom2 <- regen.glmm.selection.nbinom2[[1]]
regen.mod.list.nbinom2 <- regen.glmm.selection.nbinom2[[2]]

# 4. Interactions
regen.glmm.int.selection <- glmm.int.selection('regen.density', glmm.int.predictors, mem.df.glmm, nbinom2, zero.inflation = '1')
regen.glmm.int.df <- regen.glmm.int.selection[[1]] # sig. better
regen.glmm.int.mod.list <- regen.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s)
regen.glmm.zi.selection <- glmm.zi.selection('regen.density ~ elevation*relative_regrowth + postfire_ppt + canopy_cover + (1 | fire)', 'regen.density', glmm.predictors.zi, mem.df.glmm, nbinom2)
regen.model.df.nbinom2.zi <- regen.glmm.zi.selection[[1]]
regen.mod.list.nbinom2.zi <- regen.glmm.zi.selection[[2]]

summary(regen.mod.list.nbinom2.zi[[96]])
summary(regen.mod.list.nbinom2.zi[[222]])
summary(regen.mod.list.nbinom2.zi[[32]]) # going to use this one, as it is a bit simpler than others
summary(regen.mod.list.nbinom2.zi[[187]])
summary(regen.mod.list.nbinom2.zi[[327]])

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
m1 <- glmmTMB(regen.density ~ elevation*relative_regrowth + canopy_cover + postfire_ppt + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~elevation + postfire_fitted_slope) 
AIC(m1)
m2 <- glmmTMB(regen.density ~ elevation*relative_regrowth + postfire_tmean + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~elevation + postfire_fitted_slope) 
AIC(m2)
# going to use intercept-only zero-inflated model; canopy cover and postfire_ppt sig. improves model (so including them); also tested aspect, % recovery, hli, postfire tmean, slope (but not included above to clean up code a bit)

# 7. Define top model and run model diagnostic plots
regen.top.model <- glmmTMB(regen.density ~ elevation*relative_regrowth + canopy_cover + postfire_ppt + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~elevation + postfire_fitted_slope)
simulated.regen <- simulateResiduals(fittedModel = regen.top.model, n = 1000)
plot(simulated.regen) # looks pretty good
testZeroInflation(simulated.regen) # looks good
testUniformity(simulated.regen) # looks okay
testDispersion(simulated.regen) # looks good
```


## Top Models
### Spectral
```{r}
seedling.top.model.spectral <- glmmTMB(seedling.pct ~ canopy_cover*postfire_fitted_slope + (1|fire), mem.df.glmm, gaussian, ziformula = ~canopy_cover)
summary(seedling.top.model.spectral)
AIC(seedling.top.model.spectral)
BIC(seedling.top.model.spectral)
r2_nakagawa(seedling.top.model.spectral)
simulated <- simulateResiduals(fittedModel = seedling.top.model.spectral, n = 1000)
plot(simulated) # looks meh
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

shrub.top.model.spectral <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + (1 | fire), mem.df.glmm, gaussian)
summary(shrub.top.model.spectral)
AIC(shrub.top.model.spectral)
BIC(shrub.top.model.spectral)
r2_nakagawa(shrub.top.model.spectral)
simulated <- simulateResiduals(fittedModel = shrub.top.model.spectral, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

grass.top.model.spectral <- glmmTMB(grass.pct ~ relative_regrowth*postfire_fitted_slope + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_fitted_slope) 
summary(grass.top.model.spectral)
AIC(grass.top.model.spectral)
BIC(grass.top.model.spectral)
r2_nakagawa(grass.top.model.spectral)
simulated <- simulateResiduals(fittedModel = grass.top.model.spectral, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

regen.top.model.spectral <- glmmTMB(regen.density ~ relative_regrowth*canopy_cover + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~1) 
summary(regen.top.model.spectral)
AIC(regen.top.model.spectral)
BIC(regen.top.model.spectral)
r2_nakagawa(regen.top.model.spectral)
simulated <- simulateResiduals(fittedModel = regen.top.model.spectral, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good
```

### Climate and Topography
```{r}
seedling.top.model.climtopo <- glmmTMB(seedling.pct ~ postfire_tmean*postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~elevation + postfire_ppt)
summary(seedling.top.model.climtopo)
AIC(seedling.top.model.climtopo)
BIC(seedling.top.model.climtopo)
r2_nakagawa(seedling.top.model.climtopo)
simulated <- simulateResiduals(fittedModel = seedling.top.model.climtopo, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

shrub.top.model.climtopo <- glmmTMB(shrub.pct ~ elevation*slope + aspect + (1 | fire), mem.df.glmm, gaussian)
summary(shrub.top.model.climtopo)
AIC(shrub.top.model.climtopo)
BIC(shrub.top.model.climtopo)
r2_nakagawa(shrub.top.model.climtopo)
simulated <- simulateResiduals(fittedModel = shrub.top.model.climtopo, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

grass.top.model.climtopo <- glmmTMB(grass.pct ~ aspect + postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt) 
summary(grass.top.model.climtopo)
AIC(grass.top.model.climtopo)
BIC(grass.top.model.climtopo)
r2_nakagawa(grass.top.model.climtopo)
simulated <- simulateResiduals(fittedModel = grass.top.model.climtopo, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

regen.top.model.climtopo <- glmmTMB(regen.density ~ hli*aspect + postfire_ppt + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~1) 
summary(regen.top.model.climtopo)
AIC(regen.top.model.climtopo)
BIC(regen.top.model.climtopo)
r2_nakagawa(regen.top.model.climtopo)
simulated <- simulateResiduals(fittedModel = regen.top.model.climtopo, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good
```

### All Predictors
```{r}
seedling.top.model.all <- glmmTMB(seedling.pct ~ postfire_fitted_slope*postfire_ppt + (1|fire), mem.df.glmm, gaussian, ziformula = ~postfire_ppt + slope)
summary(seedling.top.model.all)
AIC(seedling.top.model.all)
BIC(seedling.top.model.all)
r2_nakagawa(seedling.top.model.all)
simulated <- simulateResiduals(fittedModel = seedling.top.model.all, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

shrub.top.model.all <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + (1 | fire), mem.df.glmm, gaussian)
summary(shrub.top.model.all)
AIC(shrub.top.model.all)
BIC(shrub.top.model.all)
r2_nakagawa(shrub.top.model.all)
simulated <- simulateResiduals(fittedModel = shrub.top.model.all, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

grass.top.model.all <- glmmTMB(grass.pct ~ postfire_tmean*pct_recovery + postfire_ppt + delta_ndvi + (1|fire), mem.df.glmm, gaussian, ziformula= ~ pct_recovery) 
summary(grass.top.model.all)
AIC(grass.top.model.all)
BIC(grass.top.model.all)
r2_nakagawa(grass.top.model.all)
simulated <- simulateResiduals(fittedModel = grass.top.model.all, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

regen.top.model.all <- glmmTMB(regen.density ~ elevation*relative_regrowth + canopy_cover + postfire_ppt + (1 | fire), mem.df.glmm, nbinom2, ziformula = ~elevation + postfire_fitted_slope)
summary(regen.top.model.all)
AIC(regen.top.model.all)
BIC(regen.top.model.all)
r2_nakagawa(regen.top.model.all)
simulated <- simulateResiduals(fittedModel = regen.top.model.all, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good
```

# 2. TE Model Selections
```{r}
# trailing edge
te.glmm.df <- mem.df.glmm %>% 
  filter(TE_future == 'Y')

# persistent forest
forest.glmm.df <- mem.df.glmm %>% 
  filter(TE_future == 'N')
```

### Models
```{r}
shrub.te.pf.glmm <- glmmTMB(shrub.pct ~ postfire_fitted_slope*TE_future + postfire_ppt*TE_future + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
seedling.te.pf.glmm <- glmmTMB(seedling.pct ~ postfire_fitted_slope*TE_future + postfire_ppt*TE_future + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
grass.te.pf.glmm <- glmmTMB(grass.pct ~ postfire_fitted_slope*TE_future + postfire_ppt*TE_future + (1|fire), mem.df.glmm, gaussian, ziformula = ~1)
regen.te.pf.glmm <- glmmTMB(regen.density ~ postfire_fitted_slope*TE_future + postfire_ppt*TE_future + (1|fire), mem.df.glmm, nbinom2, ziformula = ~1)
```

### Diagnostics
```{r}
# trailing edge
simulated <- simulateResiduals(fittedModel = shrub.te.glmm, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = seedling.te.glmm, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks decent
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = grass.te.glmm, n = 1000)
plot(simulated) # looks a bit funky
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = regen.te.glmm, n = 1000)
plot(simulated) # looks pretty good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks okay

# persistent forest
simulated <- simulateResiduals(fittedModel = shrub.pf.glmm, n = 1000)
plot(simulated) # looks pretty good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = seedling.pf.glmm, n = 1000)
plot(simulated) # looks pretty good
testZeroInflation(simulated) # looks decent
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = grass.pf.glmm, n = 1000)
plot(simulated) # looks a bit funky
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = regen.pf.glmm, n = 1000)
plot(simulated) # looks pretty good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

# interactions
simulated <- simulateResiduals(fittedModel = shrub.te.pf.glmm, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = seedling.te.pf.glmm, n = 1000)
plot(simulated) # looks funky
testZeroInflation(simulated) # looks decent
testUniformity(simulated) # does not look good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = grass.te.pf.glmm, n = 1000)
plot(simulated) # looks pretty good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good

simulated <- simulateResiduals(fittedModel = regen.te.pf.glmm, n = 1000)
plot(simulated) # looks good
testZeroInflation(simulated) # looks good
testUniformity(simulated) # looks good
testDispersion(simulated) # looks good
```

### Model Output Dataframe
```{r}
shrub.te.model.output <- tidy(shrub.te.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'shrub.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
seedling.te.model.output <- tidy(seedling.te.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'seedling.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
grass.te.model.output <- tidy(grass.te.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'grass.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
regen.te.model.output <- tidy(regen.te.glmm)%>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'regen.density') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
te.model.output <- rbind(shrub.te.model.output, grass.te.model.output, seedling.te.model.output, regen.te.model.output) %>% 
  mutate(trailing.edge = 'yes')

shrub.pf.model.output <- tidy(shrub.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'shrub.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
seedling.pf.model.output <- tidy(seedling.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'seedling.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
grass.pf.model.output <- tidy(grass.pf.glmm)%>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'grass.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
regen.pf.model.output <- tidy(regen.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'regen.density') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
pf.model.output <- rbind(shrub.pf.model.output, grass.pf.model.output, seedling.pf.model.output, regen.pf.model.output) %>% 
  mutate(trailing.edge = 'no')

both.model.output <- rbind(te.model.output, pf.model.output) %>% 
  mutate(sig = case_when(p.value > 0.05 ~ 'no',
                         p.value < 0.05 ~ 'yes'))  %>% 
  mutate(trailing.edge.sig = case_when(sig == 'yes' & trailing.edge == 'yes' ~ 'yes*',
                                       sig == 'yes' & trailing.edge == 'no' ~ 'no*',
                                       sig == 'no' & trailing.edge == 'yes' ~ 'yes',
                                       sig == 'no' & trailing.edge == 'no' ~ 'no'))
```

#### Interactions
```{r}
shrub.te.pf.model.output <- tidy(shrub.te.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'shrub.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
seedling.te.pf.model.output <- tidy(seedling.te.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'seedling.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
grass.te.pf.model.output <- tidy(grass.te.pf.glmm) %>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'grass.pct') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
regen.te.pf.model.output <- tidy(regen.te.pf.glmm)%>% 
  select(effect, component, term, estimate, std.error, p.value) %>% 
  mutate(response = 'regen.density') %>% 
  filter(effect == 'fixed', component == 'cond') %>% 
  select(-component)
te.pf.model.output <- rbind(shrub.te.pf.model.output, grass.te.pf.model.output, seedling.te.pf.model.output, regen.te.pf.model.output) %>% 
  mutate(sig = case_when(p.value > 0.05 ~ 'no',
                         p.value < 0.05 ~ 'yes')) 
```

### Figure
Was tough for me to get everything how I liked it so I ended up approaching it in a rather convoluted fashion
```{r}
# Not interested in intercept; taking % grass out of this figuree
both.model.output.plottable <- both.model.output %>% 
  filter(term != '(Intercept)') %>% 
  filter(response != 'grass.pct')

# Setting up dummy dataframe to expand limits
term <- c(rep('postfire_fitted_slope', 3))
response <- c('seedling.pct', 'shrub.pct', 'regen.density')
x.val <- c(-20.2, -21, -3)
dummy <- data.frame(term, response, x.val)

# Facet label (response var) names
response_var_names <- c(seedling.pct = '% Juvenile conifer',
                     shrub.pct = '% Shrub',
                     regen.density = 'Regeneration density',
                     grass.pct = '% Grass')

plot <- both.model.output.plottable %>% 
  ggplot(aes(y = term, color = term)) +
    geom_point(aes(x = estimate, shape = trailing.edge.sig), 
               size = 6.5, 
       position=position_nudge(y=ifelse(both.model.output.plottable$trailing.edge == 'yes',
                                                0.25, -0.25))) +
    geom_linerange(aes(xmin = estimate-std.error, xmax = estimate+std.error), linewidth = 0.5,
                  position=position_nudge(y=ifelse(both.model.output.plottable$trailing.edge == 'yes',
                                                0.25, -0.25))) +
    labs(x = 'Model Estimate') +
    geom_vline(xintercept = 0, linetype = 'dashed') +
    geom_blank(aes(x = x.val, y = term), data = dummy) +
    facet_wrap(~response, ncol = 1, strip.position = 'left', scales = 'free',
               labeller = as_labeller(response_var_names)) +
    scale_shape_manual(values = c(1, 19, 2, 17)) +
    scale_color_manual(values = c('darkred', 'darkblue')) +
    theme_bw() +
    theme(strip.background = element_blank(),
          strip.placement = 'outside', 
          panel.grid = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          legend.position = 'none',
          strip.text = element_text(size = 20, face = 'bold'),
          axis.text.x = element_text(size = 18),
          axis.title.x = element_text(size = 18, face = 'bold'))
plot

# Legend 1
legend1 <- get_legend(both.model.output.plottable %>% 
  mutate(term = case_when(term == 'postfire_fitted_slope' ~ 'Post-fire Fitted Slope',
                          term == 'postfire_ppt' ~ 'Post-fire Precipitation')) %>% 
  mutate(sig = case_when(sig == 'yes' ~ 'p < 0.05',
                          sig == 'no' ~ 'p > 0.05')) %>% 
  ggplot(aes(y = term, color = term)) +
    geom_point(aes(x = estimate, shape = sig), 
               size = 5) +
    geom_linerange(aes(xmin = estimate-std.error, xmax = estimate+std.error)) +
    labs(color = 'Predictor', shape = 'P-Value') +
    scale_shape_manual(values = c(19, 1)) +
    scale_color_manual(values = c('darkred', 'darkblue')) +
    theme_bw() +
    theme(legend.position = 'top',
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16, face = 'bold')))

# Legend 2
legend2 <- get_legend(both.model.output.plottable %>% 
  mutate(trailing.edge = case_when(trailing.edge == 'yes' ~ 'Trailing Edge',
                          trailing.edge == 'no' ~ 'Persistent Forest')) %>% 
  ggplot(aes(y = term)) +
    geom_point(aes(x = estimate, shape = trailing.edge), 
               size = 5) +
    scale_shape_manual(values = c(19, 17)) +
    theme_bw() +
    theme(legend.position = 'top',
          legend.text = element_text(size = 16, face = 'bold'),
          legend.title = element_blank()))

# Legends
legends <- plot_grid(legend2, legend1, ncol = 1)
legends

# Arrange
te_vs_pf_estimates_plot <- plot_grid(legends, plot, ncol = 1, rel_heights = c(1, 7))
te_vs_pf_estimates_plot
```

#### Interactions
Was tough for me to get everything how I liked it so I ended up approaching it in a rather convoluted fashion
```{r}
# Not interested in intercept; taking % grass out of this figure
te.pf.model.output.plottable <- te.pf.model.output %>% 
  filter(term != '(Intercept)')

# Setting up dummy dataframe to expand limits
term <- c(rep('PFFS', 4))
response <- c('seedling.pct', 'shrub.pct', 'regen.density', 'grass.pct')
x.val <- c(-21.05, -20.3, -1.8, -18.4)
dummy <- data.frame(term, response, x.val)

plot.int <- te.pf.model.output.plottable %>% 
  mutate(term = case_when(term == 'postfire_fitted_slope' ~ 'PFFS',
                          term == 'TE_futureY' ~ 'Trailing \nedge',
                          term == 'postfire_ppt' ~ 'Precip.',
                          term == 'postfire_fitted_slope:TE_futureY' ~ 'PFFS \n x TE',
                          term == 'TE_futureY:postfire_ppt' ~ 'Precip. \n x TE')) %>% 
  ggplot(aes(y = term)) +
    geom_point(aes(x = estimate, shape = sig), 
               size = 10.5) +
    geom_linerange(aes(xmin = estimate-std.error, xmax = estimate+std.error), linewidth = 1) +
    labs(x = 'Model estimate') +
    geom_vline(xintercept = 0, linetype = 'dashed', linewidth = 0.7) +
    geom_blank(aes(x = x.val, y = term), data = dummy) +
    facet_wrap(~factor(response, c('regen.density', 'seedling.pct', 'shrub.pct', 'grass.pct')), ncol = 2, strip.position = 'left', scales = 'free',
               labeller = as_labeller(response_var_names)) +
    scale_shape_manual(values = c(1, 19)) +
    theme_bw() +
    theme(strip.background = element_blank(),
          strip.placement = 'outside', 
          panel.grid = element_blank(),
          axis.text.y = element_text(size = 20, angle = 45, hjust = 0.5),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          legend.position = 'none',
          strip.text = element_text(size = 24, face = 'bold'),
          axis.text.x = element_text(size = 20),
          axis.title.x = element_text(size = 22, face = 'bold'))
plot.int

# Legend 1
legend.int1 <- get_legend(te.pf.model.output.plottable %>% 
  mutate(sig = case_when(sig == 'yes' ~ 'p < 0.05',
                          sig == 'no' ~ 'p > 0.05')) %>% 
  ggplot(aes(y = term)) +
    geom_point(aes(x = estimate, shape = sig), 
               size = 10.5) +
    geom_linerange(aes(xmin = estimate-std.error, xmax = estimate+std.error), linewidth = 1) +
    labs(color = 'Predictor', shape = 'P-value') +
    scale_shape_manual(values = c(19, 1)) +
    theme_bw() +
    theme(legend.position = 'top',
          legend.text = element_text(size = 25),
          legend.title = element_text(size = 25, face = 'bold')))

# Arrange
te_vs_pf_estimates_int_plot <- plot_grid(legend.int1, plot.int, ncol = 1, rel_heights = c(1, 9))
te_vs_pf_estimates_int_plot
```

# 3. NBR vs. NDVI
```{r}
nbr.field.cluster.df <- read.csv(here('data', 'processed_data', 'field.cluster.df.csv'))
colnames(nbr.field.cluster.df)[26:49] <- c(0:23)

nbr.mem.df.glmm <- nbr.field.cluster.df %>% 
  drop_na(slope) %>% 
  mutate(postdisturbance_nbr = scale(postdisturbance_nbr), delta_nbr = scale(delta_nbr), relative_regrowth = scale(relative_regrowth), pct_recovery = scale(pct_recovery), postfire_fitted_rsq = scale(postfire_fitted_rsq), postfire_fitted_slope = scale(postfire_fitted_slope), hli = scale(hli), precip = scale(precip), tmean = scale(tmean), vpdmax = scale(vpdmax), seedling.density = scale(seedling.density), aspect = scale(aspect), slope = scale(slope), dnbr = scale(dnbr), canopy_cover = scale(canopy_cover), cwd_present = scale(cwd_present), elevation = scale(elevation), postfire_ppt = scale(postfire_ppt), postfire_tmax = scale(postfire_tmax), postfire_vpdmax = scale(postfire_vpdmax), postfire_tmean = scale(postfire_tmean)) %>% 
  select(postdisturbance_nbr, delta_nbr, relative_regrowth, pct_recovery, postfire_fitted_slope, dnbr, Plot)

ndvi.mem.df.glmm <- mem.df.glmm %>% 
  select(postdisturbance_ndvi, delta_ndvi, relative_regrowth, pct_recovery, postfire_fitted_slope, precip, tmean, vpdmax, aspect, slope, canopy_cover, cwd_present, elevation, postfire_ppt, postfire_tmean, postfire_tmax, postfire_vpdmax, log.regen.density, regen.density, seedling.pct, grass.pct, shrub.pct, Plot, fire) %>% 
  rename(relative_reg_ndvi = relative_regrowth, pct_recovery_ndvi = pct_recovery, pffs_ndvi = postfire_fitted_slope)

glmm.df.compare <- merge(nbr.mem.df.glmm, ndvi.mem.df.glmm, by = 'Plot')
```

## Data Wrangling
```{r}
glmm.predictors.compare <- glmm.df.compare %>% 
  select(relative_regrowth, relative_reg_ndvi, postfire_fitted_slope, pffs_ndvi, pct_recovery, pct_recovery_ndvi, delta_ndvi, delta_nbr, dnbr) # omitted postfire_vpdmax, pct_recovery, aspect, postfire_tmax, canopy_cover to add elevation, postfire_ppt, cwd_present, dndvi , postfire_tmean, hli

glmm.int.predictors.compare <- c('relative_regrowth', 'relative_reg_ndvi', 'postfire_fitted_slope', 'pffs_ndvi', 'pct_recovery', 'pct_recovery_ndvi', 'delta_ndvi', 'delta_nbr', 'dnbr')
```

### % Seedling
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
seedling.gaussian.glmm <- glmmTMB(seedling.pct ~ elevation + postfire_ppt + (1|fire), glmm.df.compare, gaussian)
simulated.seedling.gaussian.glmm <- simulateResiduals(fittedModel = seedling.gaussian.glmm, n = 1000)
testZeroInflation(simulated.seedling.gaussian.glmm) # zero-inflated
## Using AIC
seedling.gaussian.glmm.zi <- glmmTMB(seedling.pct ~ elevation + postfire_ppt + (1|fire), glmm.df.compare, gaussian, ziformula = ~1)
AIC(seedling.gaussian.glmm)
AIC(seedling.gaussian.glmm.zi) # significant improvement

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
simulated.seedling.gaussian.glmm <- simulateResiduals(fittedModel = seedling.gaussian.glmm.zi, n = 1000)
plot(simulated.seedling.gaussian.glmm) # looks meh

seedling.binomial.glmm <- glmmTMB(seedling.pct/100 ~ elevation + postfire_ppt + (1|fire), glmm.df.compare, binomial, ziformula = ~1)
simulated.seedling.binomial.glmm <- simulateResiduals(fittedModel = seedling.binomial.glmm, n = 1000)
plot(simulated.seedling.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with just ziformula = ~1)
seed.glmm.selection.gaussian <- glmm.selection('seedling.pct', glmm.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '1')
seed.model.df.gaussian <- seed.glmm.selection.gaussian[[1]]
seed.mod.list.gaussian <- seed.glmm.selection.gaussian[[2]]

# 4. Interactions
seed.glmm.int.selection <- glmm.int.selection('seedling.pct', glmm.int.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '1')
seed.glmm.int.df <- seed.glmm.int.selection[[1]] # sig. worse

# 5. Zero-inflated Model Selection(s): if not too much of an ask, try to run these for all 'top-performing models'
seed.glmm.zi.selection <- glmm.zi.selection('seedling.pct ~ pct_recovery_ndvi + relative_reg_ndvi + relative_regrowth + (1 | fire)', 'seedling.pct', glmm.predictors.compare, glmm.df.compare, gaussian)
seed.model.df.gaussian.zi <- seed.glmm.zi.selection[[1]]
seed.mod.list.gaussian.zi <- seed.glmm.zi.selection[[2]]

seed.glmm.zi.selection <- glmm.zi.selection('seedling.pct ~ pct_recovery_ndvi + postfire_fitted_slope + relative_reg_ndvi + relative_regrowth + (1 | fire)', 'seedling.pct', glmm.predictors.compare, glmm.df.compare, gaussian)
seed.model.df.gaussian.zi <- seed.glmm.zi.selection[[1]]
seed.mod.list.gaussian.zi <- seed.glmm.zi.selection[[2]]

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(seed.mod.list.gaussian.zi[[24]]) # best zero inflation structure and best fixed effects structure
summary(seed.mod.list.gaussian.zi[[80]]) 
summary(seed.mod.list.gaussian.zi[[84]]) 
summary(seed.mod.list.gaussian.zi[[24]])

# 7. Define top model and run model diagnostic plots
seedling.top.model <- glmmTMB(seedling.pct ~ pct_recovery_ndvi + relative_reg_ndvi + relative_regrowth + (1|fire), glmm.df.compare, gaussian, ziformula = ~delta_ndvi + relative_reg_ndvi)
summary(seedling.top.model)
AIC(seedling.top.model)
BIC(seedling.top.model)
r2_nakagawa(seedling.top.model)
simulated.seedling <- simulateResiduals(fittedModel = seedling.top.model, n = 1000)
plot(simulated.seedling) # looks meh
testZeroInflation(simulated.seedling) # looks good
testUniformity(simulated.seedling) # looks good
testDispersion(simulated.seedling) # looks good
```

### % Shrub
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
shrub.gaussian.glmm <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + dnbr + (1|fire), glmm.df.compare, gaussian)
simulated.shrub.gaussian.glmm <- simulateResiduals(fittedModel = shrub.gaussian.glmm, n = 1000)
testZeroInflation(simulated.shrub.gaussian.glmm) # zero-inflated
## Using AIC
shrub.gaussian.glmm.zi <- glmmTMB(shrub.pct ~ delta_ndvi + postfire_fitted_slope + dnbr + (1|fire), glmm.df.compare, gaussian, ziformula = ~1)
AIC(shrub.gaussian.glmm)
AIC(shrub.gaussian.glmm.zi) # not a significant improvement; stick to no zero inflation

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
plot(simulated.shrub.gaussian.glmm) # looks good!

shrub.binomial.glmm <- glmmTMB(shrub.pct/100 ~ delta_ndvi + postfire_fitted_slope + dnbr + (1|fire), glmm.df.compare, binomial)
simulated.shrub.binomial.glmm <- simulateResiduals(fittedModel = shrub.binomial.glmm, n = 1000)
plot(simulated.shrub.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (no zero inflation)
shrub.glmm.selection.gaussian <- glmm.selection('shrub.pct', glmm.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '0')
shrub.model.df.gaussian <- shrub.glmm.selection.gaussian[[1]]
shrub.mod.list.gaussian <- shrub.glmm.selection.gaussian[[2]]

# 4. Interactions
shrub.glmm.int.selection <- glmm.int.selection('shrub.pct', glmm.int.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '0')
shrub.glmm.int.df <- shrub.glmm.int.selection[[1]] # sig. worse

# 5. Zero-inflated Model Selection(s): not applicable

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(shrub.mod.list.gaussian[[67]]) # lowest AIC and BIC
summary(shrub.mod.list.gaussian[[188]]) # RR not sig
summary(shrub.mod.list.gaussian[[187]]) # RR_NDVI and pct recovery not sig
# Selecting model no. 67

# 7. Define top model and run model diagnostic plots
shrub.top.model <- glmmTMB(shrub.pct ~ delta_ndvi + dnbr + pffs_ndvi + (1 | fire), glmm.df.compare, gaussian)
summary(shrub.top.model)
AIC(shrub.top.model)
BIC(shrub.top.model)
r2_nakagawa(shrub.top.model)
simulated.shrub <- simulateResiduals(fittedModel = shrub.top.model, n = 1000)
plot(simulated.shrub) # looks great
testZeroInflation(simulated.shrub) # zero inflated, but only one zero so not a big deal
testUniformity(simulated.shrub) # looks good
testDispersion(simulated.shrub) # looks good
```

### % Grass
Picking out distribution
```{r}
# 1. Test for zero inflation (using gaussian model, for now)
## Using DHARMa package
grass.gaussian.glmm <- glmmTMB(grass.pct ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), glmm.df.compare, gaussian)
simulated.grass.gaussian.glmm <- simulateResiduals(fittedModel = grass.gaussian.glmm, n = 1000)
testZeroInflation(simulated.grass.gaussian.glmm) # zero-inflated
## Using AIC
grass.gaussian.glmm.zi <- glmmTMB(grass.pct ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), glmm.df.compare, gaussian, ziformula = ~1)
AIC(grass.gaussian.glmm)
AIC(grass.gaussian.glmm.zi) # not significant improvement; but we can test anyways

# 2. Using top models identified in gaussian model selection (above), test different families (for % data, try Binomial distributions) and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
plot(simulated.grass.gaussian.glmm) # qqplot looks good; residual plot looks meh

grass.binomial.glmm <- glmmTMB(grass.pct/100 ~ postfire_ppt + postfire_fitted_slope*postfire_tmean + (1|fire), glmm.df.compare, binomial)
simulated.grass.binomial.glmm <- simulateResiduals(fittedModel = grass.binomial.glmm, n = 1000)
plot(simulated.grass.binomial.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (first with no zero inflation)
grass.glmm.selection.gaussian <- glmm.selection('grass.pct', glmm.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '0')
grass.model.df.gaussian <- grass.glmm.selection.gaussian[[1]]
grass.mod.list.gaussian <- grass.glmm.selection.gaussian[[2]]

# 4. Interactions
grass.glmm.int.selection <- glmm.int.selection('grass.pct', glmm.int.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '0')
grass.glmm.int.df <- grass.glmm.int.selection[[1]] # sig. better
grass.glmm.int.mod.list <- grass.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s): not working for % grass because only a few zero values; however, we will try a couple of different zero inflation formulas to test the impact on the AIC
grass.glmm.zi.selection.mod1 <- glmmTMB(grass.pct ~ relative_reg_ndvi*pffs_ndvi + (1|fire), glmm.df.compare, gaussian, ziformula= ~ 1) 
AIC(grass.glmm.zi.selection.mod1) # sig. better
grass.glmm.zi.selection.mod2 <- glmmTMB(grass.pct ~ relative_reg_ndvi*pffs_ndvi + (1|fire), glmm.df.compare, gaussian, ziformula= ~ relative_reg_ndvi) 
AIC(grass.glmm.zi.selection.mod2) # slightly better
grass.glmm.zi.selection.mod3 <- glmmTMB(grass.pct ~ relative_reg_ndvi*pffs_ndvi + delta_ndvi + (1|fire), glmm.df.compare, gaussian, ziformula= ~ pffs_ndvi) 
AIC(grass.glmm.zi.selection.mod3) # sig. better, slightly better than mod1


# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(grass.glmm.int.mod.list[[10]]) # relative_reg_ndvi not significant
summary(grass.glmm.zi.selection.mod3) # although only 3 zero values and only a slight improvement of AIC score, zero inflation may be necessary for this model
summary(grass.glmm.int.mod.list[[3]]) # relative_regrowth not significant
r2_nakagawa(grass.glmm.int.mod.list[[10]]) # higher conditional rsq but lower marginal rsq
r2_nakagawa(grass.glmm.int.mod.list[[3]]) # higher marginal rsq but lower conditional rsq
r2_nakagawa(grass.glmm.zi.selection.mod3) # sig. higher marginal and conditional rsq
# going to use grass.glmm.zi.selection.mod3 due to lower AIC, BIC and higher conditional rsq

# 7. Define top model and run model diagnostic plots
grass.top.model <- glmmTMB(grass.pct ~ relative_reg_ndvi*pffs_ndvi + delta_ndvi + (1|fire), glmm.df.compare, gaussian, ziformula= ~ pffs_ndvi) 
summary(grass.top.model)
AIC(grass.top.model)
BIC(grass.top.model)
r2_nakagawa(grass.top.model)
simulated.grass <- simulateResiduals(fittedModel = grass.top.model, n = 1000)
plot(simulated.grass) # looks good
testZeroInflation(simulated.grass) # looks good
testUniformity(simulated.grass) # looks good
testDispersion(simulated.grass) # looks good
```

### Regen Density
Picking out distribution: for density, we can test gaussian (if log-transformed), poisson, negative binomial 1 and negative binomial 2 (more options)
```{r}
# 1. Test for zero inflation (using gaussian model w/ log.regen.density, for now)
## Using DHARMa package
regen.gaussian.glmm <- glmmTMB(log.regen.density ~ slope*postfire_vpdmax + (1|fire), glmm.df.compare, gaussian)
simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.gaussian.glmm, n = 1000)
testZeroInflation(simulated.regen.gaussian.glmm) # zero-inflated
## Using AIC
regen.gaussian.glmm.zi <- glmmTMB(log.regen.density ~ slope*postfire_vpdmax + (1|fire), glmm.df.compare, gaussian, ziformula = ~1)
AIC(regen.gaussian.glmm)
AIC(regen.gaussian.glmm.zi) # significant improvement

# 2. Using top models identified in gaussian model selection (above), test different families  and run diagnostic plots on each of them; if zero-inflated, use zero-inflated = ~1 for now
simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.gaussian.glmm.zi, n = 1000)
plot(simulated.regen.gaussian.glmm) # actually, looks great!

regen.nbinom1.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), glmm.df.compare, nbinom1, ziformula = ~1)
simulated.regen.nbinom1.glmm <- simulateResiduals(fittedModel = regen.nbinom1.glmm, n = 1000)
plot(simulated.regen.nbinom1.glmm) # looks okay, but worse than gaussian

regen.nbinom2.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), glmm.df.compare, nbinom2, ziformula = ~1)
simulated.regen.nbinom2.glmm <- simulateResiduals(fittedModel = regen.nbinom2.glmm, n = 1000)
plot(simulated.regen.nbinom2.glmm) # looks good, but worse than gaussian

regen.poisson.glmm <- glmmTMB(regen.density ~ slope*postfire_vpdmax + (1|fire), glmm.df.compare, poisson, ziformula = ~1)
simulated.regen.poisson.glmm <- simulateResiduals(fittedModel = regen.poisson.glmm, n = 1000)
plot(simulated.regen.poisson.glmm) # looks BAD

# BEST DISTRIBUTION: GAUSSIAN or NBINOM2
```

Choosing predictors and ziformula
```{r}
# 3. Model Selection (for now, just with ziformula = ~1)
regen.glmm.selection.gaussian <- glmm.selection('log.regen.density', glmm.predictors.compare, glmm.df.compare, gaussian, zero.inflation = '1')
regen.model.df.gaussian <- regen.glmm.selection.gaussian[[1]]
regen.mod.list.gaussian <- regen.glmm.selection.gaussian[[2]]

regen.glmm.selection.nbinom2 <- glmm.selection('regen.density', glmm.predictors.compare, glmm.df.compare, nbinom2, zero.inflation = '1')
regen.model.df.nbinom2 <- regen.glmm.selection.nbinom2[[1]]
regen.mod.list.nbinom2 <- regen.glmm.selection.nbinom2[[2]]
# AIC for the two families is incomparable, Rsq is higher for nbinom2; let's check out diagnostic plots to decide which to choose
regen.mod.list.gaussian[[16]]
regen.mod.list.nbinom2[[16]]

simulated.regen.gaussian.glmm <- simulateResiduals(fittedModel = regen.mod.list.gaussian[[45]], n = 1000)
plot(simulated.regen.gaussian.glmm) # looks great
simulated.regen.nbinom2.glmm <- simulateResiduals(fittedModel = regen.mod.list.nbinom2[[45]], n = 1000)
plot(simulated.regen.nbinom2.glmm) # looks pretty good

# although the nbinom2 looks slightly worse than the gaussian, I am going to select this distribution, as it prevents the log-transformation

# 4. Interactions
regen.glmm.int.selection <- glmm.int.selection('regen.density', glmm.int.predictors.compare, glmm.df.compare, nbinom2, zero.inflation = '1')
regen.glmm.int.df <- regen.glmm.int.selection[[1]] # sig. better
regen.glmm.int.mod.list <- regen.glmm.int.selection[[2]]

# 5. Zero-inflated Model Selection(s)
regen.glmm.zi.selection <- glmm.zi.selection('regen.density ~ relative_regrowth*delta_nbr + (1 | fire)', 'regen.density', glmm.predictors.compare, glmm.df.compare, nbinom2)
regen.model.df.nbinom2.zi <- regen.glmm.zi.selection[[1]]
regen.mod.list.nbinom2.zi <- regen.glmm.zi.selection[[2]]
# By intercept is best model...

# 6. Choose Model Structure(s): This is where the 'art' of modeling comes into play; we have plenty of information above, but some models are not significantly different from each other. Using AIC, BIC, Rsq and significance of variables, we will figure out which model we want to display
summary(regen.mod.list.nbinom2.zi[[1]]) # intercept only; intercept is sig.
summary(regen.mod.list.nbinom2.zi[[10]]) # dnbr not sig.
summary(regen.mod.list.nbinom2.zi[[5]]) # pffs_ndvi not sig.
r2_nakagawa(regen.mod.list.nbinom2.zi[[1]]) # ...
r2_nakagawa(regen.mod.list.nbinom2.zi[[10]]) # same as above
r2_nakagawa(regen.mod.list.nbinom2.zi[[5]]) # same as above
# going to use intercept-only zero-inflated model (lowest AIC and other variables not significant)

# 7. Define top model and run model diagnostic plots
regen.top.model <- glmmTMB(regen.density ~ relative_regrowth*delta_nbr + (1 | fire), glmm.df.compare, nbinom2, ziformula = ~1) 
AIC(regen.top.model)
BIC(regen.top.model)
r2_nakagawa(regen.top.model)
summary(regen.top.model)
simulated.regen <- simulateResiduals(fittedModel = regen.top.model, n = 1000)
plot(simulated.regen) # residuals look pretty ugly
testZeroInflation(simulated.regen) # looks good
testUniformity(simulated.regen) # not uniform
testDispersion(simulated.regen) # looks good
```

## NDVI Models
```{r}
regen.ndvi.model <- glmmTMB(regen.density ~ relative_reg_ndvi + pffs_ndvi + pct_recovery_ndvi + delta_ndvi + (1 | fire), glmm.df.compare, nbinom2, ziformula = ~1)
summary(regen.ndvi.model)
AIC(regen.ndvi.model)
BIC(regen.ndvi.model)
r2_nakagawa(regen.ndvi.model)
simulated.regen <- simulateResiduals(fittedModel = regen.ndvi.model, n = 1000)
plot(simulated.regen) # residuals look very ugly
testZeroInflation(simulated.regen) # looks good
testUniformity(simulated.regen) # looks good
testDispersion(simulated.regen) # looks good

seed.ndvi.model <- glmmTMB(seedling.pct ~ relative_reg_ndvi + pffs_ndvi + pct_recovery_ndvi + delta_ndvi + (1 | fire), glmm.df.compare, gaussian, ziformula = ~1)
summary(seed.ndvi.model)
AIC(seed.ndvi.model)
BIC(seed.ndvi.model)
r2_nakagawa(seed.ndvi.model)
simulated.seed <- simulateResiduals(fittedModel = seed.ndvi.model, n = 1000)
plot(simulated.seed) # look good!
testZeroInflation(simulated.seed) # looks good
testUniformity(simulated.seed) # looks good
testDispersion(simulated.seed) # looks good 

shrub.ndvi.model <- glmmTMB(shrub.pct ~ relative_reg_ndvi + pffs_ndvi + pct_recovery_ndvi + delta_ndvi + (1 | fire), glmm.df.compare, gaussian)
summary(shrub.ndvi.model)
AIC(shrub.ndvi.model)
BIC(shrub.ndvi.model)
r2_nakagawa(shrub.ndvi.model)
simulated.shrub <- simulateResiduals(fittedModel = shrub.ndvi.model, n = 1000)
plot(simulated.shrub) # looks good
testZeroInflation(simulated.shrub) # zero inflated, but only one zero so probably doesn't matter
testUniformity(simulated.shrub) # looks good
testDispersion(simulated.shrub) # looks good 

grass.ndvi.model <- glmmTMB(grass.pct ~ relative_reg_ndvi + pffs_ndvi + pct_recovery_ndvi + delta_ndvi + (1 | fire), glmm.df.compare, gaussian, ziformula = ~1)
summary(grass.ndvi.model)
AIC(grass.ndvi.model)
BIC(grass.ndvi.model)
r2_nakagawa(grass.ndvi.model)
simulated.grass <- simulateResiduals(fittedModel = grass.ndvi.model, n = 1000)
plot(simulated.grass) # looks good
testZeroInflation(simulated.grass) # looks good
testUniformity(simulated.grass) # looks good
testDispersion(simulated.grass) # looks good 
```

## NBR Models
```{r}
regen.nbr.model <- glmmTMB(regen.density ~ relative_regrowth + postfire_fitted_slope + pct_recovery + delta_nbr + (1 | fire), glmm.df.compare, nbinom2, ziformula = ~1)
summary(regen.nbr.model)
AIC(regen.nbr.model)
BIC(regen.nbr.model)
r2_nakagawa(regen.nbr.model)
simulated.regen <- simulateResiduals(fittedModel = regen.nbr.model, n = 1000)
plot(simulated.regen) # residuals look pretty ugly
testZeroInflation(simulated.regen) # looks good
testUniformity(simulated.regen) # not uniform
testDispersion(simulated.regen) # looks good

seed.nbr.model <- glmmTMB(seedling.pct ~ relative_regrowth + postfire_fitted_slope + pct_recovery + delta_nbr + (1 | fire), glmm.df.compare, gaussian, ziformula = ~1)
summary(seed.nbr.model)
AIC(seed.nbr.model)
BIC(seed.nbr.model)
r2_nakagawa(seed.nbr.model)
simulated.seed <- simulateResiduals(fittedModel = seed.nbr.model, n = 1000)
plot(simulated.seed) # looks decent
testZeroInflation(simulated.seed) # looks good
testUniformity(simulated.seed) # looks good
testDispersion(simulated.seed) # looks good 

shrub.nbr.model <- glmmTMB(shrub.pct ~ relative_regrowth + postfire_fitted_slope + pct_recovery + delta_nbr + (1 | fire), glmm.df.compare, gaussian)
summary(shrub.nbr.model)
AIC(shrub.nbr.model)
BIC(shrub.nbr.model)
r2_nakagawa(shrub.nbr.model)
simulated.shrub <- simulateResiduals(fittedModel = shrub.nbr.model, n = 1000)
plot(simulated.shrub) # looks a bit funky, but mostly okay
testZeroInflation(simulated.shrub) # zero inflation, but only one zero value so should be okay
testUniformity(simulated.shrub) # looks good
testDispersion(simulated.shrub) # looks good 

grass.nbr.model <- glmmTMB(grass.pct ~ relative_regrowth + postfire_fitted_slope + pct_recovery + delta_nbr + (1 | fire), glmm.df.compare, gaussian, ziformula = ~1)
summary(grass.nbr.model)
AIC(grass.nbr.model)
BIC(grass.nbr.model)
r2_nakagawa(grass.nbr.model)
simulated.grass <- simulateResiduals(fittedModel = grass.nbr.model, n = 1000)
plot(simulated.grass) # looks good
testZeroInflation(simulated.grass) # looks good
testUniformity(simulated.grass) # looks good
testDispersion(simulated.grass) # looks good 
```